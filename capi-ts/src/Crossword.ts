/* tslint:disable */
/*
 * Autogenerated by @creditkarma/thrift-typescript v3.5.0
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 */
import * as thrift from '@creditkarma/thrift-server-core';
import * as __NAMESPACE__ from './.';
export interface ICrossword {
  name: string;
  type: __NAMESPACE__.CrosswordType;
  number: number;
  date: __NAMESPACE__.ICapiDateTime;
  dimensions: __NAMESPACE__.ICrosswordDimensions;
  entries: Array<__NAMESPACE__.ICrosswordEntry>;
  solutionAvailable: boolean;
  hasNumbers: boolean;
  randomCluesOrdering: boolean;
  instructions?: string;
  creator?: __NAMESPACE__.ICrosswordCreator;
  pdf?: string;
  annotatedSolution?: string;
  dateSolutionAvailable?: __NAMESPACE__.ICapiDateTime;
}
export interface ICrosswordArgs {
  name: string;
  type: __NAMESPACE__.CrosswordType;
  number: number;
  date: __NAMESPACE__.ICapiDateTimeArgs;
  dimensions: __NAMESPACE__.ICrosswordDimensionsArgs;
  entries: Array<__NAMESPACE__.ICrosswordEntryArgs>;
  solutionAvailable: boolean;
  hasNumbers: boolean;
  randomCluesOrdering: boolean;
  instructions?: string;
  creator?: __NAMESPACE__.ICrosswordCreatorArgs;
  pdf?: string;
  annotatedSolution?: string;
  dateSolutionAvailable?: __NAMESPACE__.ICapiDateTimeArgs;
}
export const CrosswordCodec: thrift.IStructCodec<ICrosswordArgs, ICrossword> = {
  encode(args: ICrosswordArgs, output: thrift.TProtocol): void {
    const obj = {
      name: args.name,
      type: args.type,
      number: args.number,
      date: args.date,
      dimensions: args.dimensions,
      entries: args.entries,
      solutionAvailable: args.solutionAvailable,
      hasNumbers: args.hasNumbers,
      randomCluesOrdering: args.randomCluesOrdering,
      instructions: args.instructions,
      creator: args.creator,
      pdf: args.pdf,
      annotatedSolution: args.annotatedSolution,
      dateSolutionAvailable: args.dateSolutionAvailable,
    };
    output.writeStructBegin('Crossword');
    if (obj.name != null) {
      output.writeFieldBegin('name', thrift.TType.STRING, 1);
      output.writeString(obj.name);
      output.writeFieldEnd();
    } else {
      throw new thrift.TProtocolException(
        thrift.TProtocolExceptionType.UNKNOWN,
        'Required field[name] is unset!'
      );
    }
    if (obj.type != null) {
      output.writeFieldBegin('type', thrift.TType.I32, 2);
      output.writeI32(obj.type);
      output.writeFieldEnd();
    } else {
      throw new thrift.TProtocolException(
        thrift.TProtocolExceptionType.UNKNOWN,
        'Required field[type] is unset!'
      );
    }
    if (obj.number != null) {
      output.writeFieldBegin('number', thrift.TType.I32, 3);
      output.writeI32(obj.number);
      output.writeFieldEnd();
    } else {
      throw new thrift.TProtocolException(
        thrift.TProtocolExceptionType.UNKNOWN,
        'Required field[number] is unset!'
      );
    }
    if (obj.date != null) {
      output.writeFieldBegin('date', thrift.TType.STRUCT, 4);
      __NAMESPACE__.CapiDateTimeCodec.encode(obj.date, output);
      output.writeFieldEnd();
    } else {
      throw new thrift.TProtocolException(
        thrift.TProtocolExceptionType.UNKNOWN,
        'Required field[date] is unset!'
      );
    }
    if (obj.dimensions != null) {
      output.writeFieldBegin('dimensions', thrift.TType.STRUCT, 5);
      __NAMESPACE__.CrosswordDimensionsCodec.encode(obj.dimensions, output);
      output.writeFieldEnd();
    } else {
      throw new thrift.TProtocolException(
        thrift.TProtocolExceptionType.UNKNOWN,
        'Required field[dimensions] is unset!'
      );
    }
    if (obj.entries != null) {
      output.writeFieldBegin('entries', thrift.TType.LIST, 6);
      output.writeListBegin(thrift.TType.STRUCT, obj.entries.length);
      obj.entries.forEach(
        (value_1: __NAMESPACE__.ICrosswordEntryArgs): void => {
          __NAMESPACE__.CrosswordEntryCodec.encode(value_1, output);
        }
      );
      output.writeListEnd();
      output.writeFieldEnd();
    } else {
      throw new thrift.TProtocolException(
        thrift.TProtocolExceptionType.UNKNOWN,
        'Required field[entries] is unset!'
      );
    }
    if (obj.solutionAvailable != null) {
      output.writeFieldBegin('solutionAvailable', thrift.TType.BOOL, 7);
      output.writeBool(obj.solutionAvailable);
      output.writeFieldEnd();
    } else {
      throw new thrift.TProtocolException(
        thrift.TProtocolExceptionType.UNKNOWN,
        'Required field[solutionAvailable] is unset!'
      );
    }
    if (obj.hasNumbers != null) {
      output.writeFieldBegin('hasNumbers', thrift.TType.BOOL, 8);
      output.writeBool(obj.hasNumbers);
      output.writeFieldEnd();
    } else {
      throw new thrift.TProtocolException(
        thrift.TProtocolExceptionType.UNKNOWN,
        'Required field[hasNumbers] is unset!'
      );
    }
    if (obj.randomCluesOrdering != null) {
      output.writeFieldBegin('randomCluesOrdering', thrift.TType.BOOL, 9);
      output.writeBool(obj.randomCluesOrdering);
      output.writeFieldEnd();
    } else {
      throw new thrift.TProtocolException(
        thrift.TProtocolExceptionType.UNKNOWN,
        'Required field[randomCluesOrdering] is unset!'
      );
    }
    if (obj.instructions != null) {
      output.writeFieldBegin('instructions', thrift.TType.STRING, 10);
      output.writeString(obj.instructions);
      output.writeFieldEnd();
    }
    if (obj.creator != null) {
      output.writeFieldBegin('creator', thrift.TType.STRUCT, 11);
      __NAMESPACE__.CrosswordCreatorCodec.encode(obj.creator, output);
      output.writeFieldEnd();
    }
    if (obj.pdf != null) {
      output.writeFieldBegin('pdf', thrift.TType.STRING, 12);
      output.writeString(obj.pdf);
      output.writeFieldEnd();
    }
    if (obj.annotatedSolution != null) {
      output.writeFieldBegin('annotatedSolution', thrift.TType.STRING, 13);
      output.writeString(obj.annotatedSolution);
      output.writeFieldEnd();
    }
    if (obj.dateSolutionAvailable != null) {
      output.writeFieldBegin('dateSolutionAvailable', thrift.TType.STRUCT, 14);
      __NAMESPACE__.CapiDateTimeCodec.encode(obj.dateSolutionAvailable, output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  },
  decode(input: thrift.TProtocol): ICrossword {
    let _args: any = {};
    input.readStructBegin();
    while (true) {
      const ret: thrift.IThriftField = input.readFieldBegin();
      const fieldType: thrift.TType = ret.fieldType;
      const fieldId: number = ret.fieldId;
      if (fieldType === thrift.TType.STOP) {
        break;
      }
      switch (fieldId) {
        case 1:
          if (fieldType === thrift.TType.STRING) {
            const value_2: string = input.readString();
            _args.name = value_2;
          } else {
            input.skip(fieldType);
          }
          break;
        case 2:
          if (fieldType === thrift.TType.I32) {
            const value_3: __NAMESPACE__.CrosswordType = input.readI32();
            _args.type = value_3;
          } else {
            input.skip(fieldType);
          }
          break;
        case 3:
          if (fieldType === thrift.TType.I32) {
            const value_4: number = input.readI32();
            _args.number = value_4;
          } else {
            input.skip(fieldType);
          }
          break;
        case 4:
          if (fieldType === thrift.TType.STRUCT) {
            const value_5: __NAMESPACE__.ICapiDateTime = __NAMESPACE__.CapiDateTimeCodec.decode(
              input
            );
            _args.date = value_5;
          } else {
            input.skip(fieldType);
          }
          break;
        case 5:
          if (fieldType === thrift.TType.STRUCT) {
            const value_6: __NAMESPACE__.ICrosswordDimensions = __NAMESPACE__.CrosswordDimensionsCodec.decode(
              input
            );
            _args.dimensions = value_6;
          } else {
            input.skip(fieldType);
          }
          break;
        case 6:
          if (fieldType === thrift.TType.LIST) {
            const value_7: Array<__NAMESPACE__.ICrosswordEntry> = new Array<
              __NAMESPACE__.ICrosswordEntry
            >();
            const metadata_1: thrift.IThriftList = input.readListBegin();
            const size_1: number = metadata_1.size;
            for (let i_1: number = 0; i_1 < size_1; i_1++) {
              const value_8: __NAMESPACE__.ICrosswordEntry = __NAMESPACE__.CrosswordEntryCodec.decode(
                input
              );
              value_7.push(value_8);
            }
            input.readListEnd();
            _args.entries = value_7;
          } else {
            input.skip(fieldType);
          }
          break;
        case 7:
          if (fieldType === thrift.TType.BOOL) {
            const value_9: boolean = input.readBool();
            _args.solutionAvailable = value_9;
          } else {
            input.skip(fieldType);
          }
          break;
        case 8:
          if (fieldType === thrift.TType.BOOL) {
            const value_10: boolean = input.readBool();
            _args.hasNumbers = value_10;
          } else {
            input.skip(fieldType);
          }
          break;
        case 9:
          if (fieldType === thrift.TType.BOOL) {
            const value_11: boolean = input.readBool();
            _args.randomCluesOrdering = value_11;
          } else {
            input.skip(fieldType);
          }
          break;
        case 10:
          if (fieldType === thrift.TType.STRING) {
            const value_12: string = input.readString();
            _args.instructions = value_12;
          } else {
            input.skip(fieldType);
          }
          break;
        case 11:
          if (fieldType === thrift.TType.STRUCT) {
            const value_13: __NAMESPACE__.ICrosswordCreator = __NAMESPACE__.CrosswordCreatorCodec.decode(
              input
            );
            _args.creator = value_13;
          } else {
            input.skip(fieldType);
          }
          break;
        case 12:
          if (fieldType === thrift.TType.STRING) {
            const value_14: string = input.readString();
            _args.pdf = value_14;
          } else {
            input.skip(fieldType);
          }
          break;
        case 13:
          if (fieldType === thrift.TType.STRING) {
            const value_15: string = input.readString();
            _args.annotatedSolution = value_15;
          } else {
            input.skip(fieldType);
          }
          break;
        case 14:
          if (fieldType === thrift.TType.STRUCT) {
            const value_16: __NAMESPACE__.ICapiDateTime = __NAMESPACE__.CapiDateTimeCodec.decode(
              input
            );
            _args.dateSolutionAvailable = value_16;
          } else {
            input.skip(fieldType);
          }
          break;
        default: {
          input.skip(fieldType);
        }
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    if (
      _args.name !== undefined &&
      _args.type !== undefined &&
      _args.number !== undefined &&
      _args.date !== undefined &&
      _args.dimensions !== undefined &&
      _args.entries !== undefined &&
      _args.solutionAvailable !== undefined &&
      _args.hasNumbers !== undefined &&
      _args.randomCluesOrdering !== undefined
    ) {
      return {
        name: _args.name,
        type: _args.type,
        number: _args.number,
        date: _args.date,
        dimensions: _args.dimensions,
        entries: _args.entries,
        solutionAvailable: _args.solutionAvailable,
        hasNumbers: _args.hasNumbers,
        randomCluesOrdering: _args.randomCluesOrdering,
        instructions: _args.instructions,
        creator: _args.creator,
        pdf: _args.pdf,
        annotatedSolution: _args.annotatedSolution,
        dateSolutionAvailable: _args.dateSolutionAvailable,
      };
    } else {
      throw new thrift.TProtocolException(
        thrift.TProtocolExceptionType.UNKNOWN,
        'Unable to read Crossword from input'
      );
    }
  },
};
export class Crossword extends thrift.StructLike implements ICrossword {
  public name: string;
  public type: __NAMESPACE__.CrosswordType;
  public number: number;
  public date: __NAMESPACE__.ICapiDateTime;
  public dimensions: __NAMESPACE__.ICrosswordDimensions;
  public entries: Array<__NAMESPACE__.ICrosswordEntry>;
  public solutionAvailable: boolean;
  public hasNumbers: boolean;
  public randomCluesOrdering: boolean;
  public instructions?: string;
  public creator?: __NAMESPACE__.ICrosswordCreator;
  public pdf?: string;
  public annotatedSolution?: string;
  public dateSolutionAvailable?: __NAMESPACE__.ICapiDateTime;
  public readonly _annotations: thrift.IThriftAnnotations = {};
  public readonly _fieldAnnotations: thrift.IFieldAnnotations = {};
  constructor(args: ICrosswordArgs) {
    super();
    if (args.name != null) {
      const value_17: string = args.name;
      this.name = value_17;
    } else {
      throw new thrift.TProtocolException(
        thrift.TProtocolExceptionType.UNKNOWN,
        'Required field[name] is unset!'
      );
    }
    if (args.type != null) {
      const value_18: __NAMESPACE__.CrosswordType = args.type;
      this.type = value_18;
    } else {
      throw new thrift.TProtocolException(
        thrift.TProtocolExceptionType.UNKNOWN,
        'Required field[type] is unset!'
      );
    }
    if (args.number != null) {
      const value_19: number = args.number;
      this.number = value_19;
    } else {
      throw new thrift.TProtocolException(
        thrift.TProtocolExceptionType.UNKNOWN,
        'Required field[number] is unset!'
      );
    }
    if (args.date != null) {
      const value_20: __NAMESPACE__.ICapiDateTime = new __NAMESPACE__.CapiDateTime(
        args.date
      );
      this.date = value_20;
    } else {
      throw new thrift.TProtocolException(
        thrift.TProtocolExceptionType.UNKNOWN,
        'Required field[date] is unset!'
      );
    }
    if (args.dimensions != null) {
      const value_21: __NAMESPACE__.ICrosswordDimensions = new __NAMESPACE__.CrosswordDimensions(
        args.dimensions
      );
      this.dimensions = value_21;
    } else {
      throw new thrift.TProtocolException(
        thrift.TProtocolExceptionType.UNKNOWN,
        'Required field[dimensions] is unset!'
      );
    }
    if (args.entries != null) {
      const value_22: Array<__NAMESPACE__.ICrosswordEntry> = new Array<
        __NAMESPACE__.ICrosswordEntry
      >();
      args.entries.forEach(
        (value_31: __NAMESPACE__.ICrosswordEntryArgs): void => {
          const value_32: __NAMESPACE__.ICrosswordEntry = new __NAMESPACE__.CrosswordEntry(
            value_31
          );
          value_22.push(value_32);
        }
      );
      this.entries = value_22;
    } else {
      throw new thrift.TProtocolException(
        thrift.TProtocolExceptionType.UNKNOWN,
        'Required field[entries] is unset!'
      );
    }
    if (args.solutionAvailable != null) {
      const value_23: boolean = args.solutionAvailable;
      this.solutionAvailable = value_23;
    } else {
      throw new thrift.TProtocolException(
        thrift.TProtocolExceptionType.UNKNOWN,
        'Required field[solutionAvailable] is unset!'
      );
    }
    if (args.hasNumbers != null) {
      const value_24: boolean = args.hasNumbers;
      this.hasNumbers = value_24;
    } else {
      throw new thrift.TProtocolException(
        thrift.TProtocolExceptionType.UNKNOWN,
        'Required field[hasNumbers] is unset!'
      );
    }
    if (args.randomCluesOrdering != null) {
      const value_25: boolean = args.randomCluesOrdering;
      this.randomCluesOrdering = value_25;
    } else {
      throw new thrift.TProtocolException(
        thrift.TProtocolExceptionType.UNKNOWN,
        'Required field[randomCluesOrdering] is unset!'
      );
    }
    if (args.instructions != null) {
      const value_26: string = args.instructions;
      this.instructions = value_26;
    }
    if (args.creator != null) {
      const value_27: __NAMESPACE__.ICrosswordCreator = new __NAMESPACE__.CrosswordCreator(
        args.creator
      );
      this.creator = value_27;
    }
    if (args.pdf != null) {
      const value_28: string = args.pdf;
      this.pdf = value_28;
    }
    if (args.annotatedSolution != null) {
      const value_29: string = args.annotatedSolution;
      this.annotatedSolution = value_29;
    }
    if (args.dateSolutionAvailable != null) {
      const value_30: __NAMESPACE__.ICapiDateTime = new __NAMESPACE__.CapiDateTime(
        args.dateSolutionAvailable
      );
      this.dateSolutionAvailable = value_30;
    }
  }
  public static read(input: thrift.TProtocol): Crossword {
    return new Crossword(CrosswordCodec.decode(input));
  }
  public static write(args: ICrosswordArgs, output: thrift.TProtocol): void {
    return CrosswordCodec.encode(args, output);
  }
  public write(output: thrift.TProtocol): void {
    return CrosswordCodec.encode(this, output);
  }
}
