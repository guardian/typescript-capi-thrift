/* tslint:disable */
/*
 * Autogenerated by @creditkarma/thrift-typescript v3.5.0
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 */
import * as thrift from '@creditkarma/thrift-server-core';
import * as __NAMESPACE__ from './.';
export interface IAsset {
  type: __NAMESPACE__.AssetType;
  mimeType?: string;
  file?: string;
  typeData?: __NAMESPACE__.IAssetFields;
}
export interface IAssetArgs {
  type: __NAMESPACE__.AssetType;
  mimeType?: string;
  file?: string;
  typeData?: __NAMESPACE__.IAssetFieldsArgs;
}
export const AssetCodec: thrift.IStructCodec<IAssetArgs, IAsset> = {
  encode(args: IAssetArgs, output: thrift.TProtocol): void {
    const obj = {
      type: args.type,
      mimeType: args.mimeType,
      file: args.file,
      typeData: args.typeData,
    };
    output.writeStructBegin('Asset');
    if (obj.type != null) {
      output.writeFieldBegin('type', thrift.TType.I32, 1);
      output.writeI32(obj.type);
      output.writeFieldEnd();
    } else {
      throw new thrift.TProtocolException(
        thrift.TProtocolExceptionType.UNKNOWN,
        'Required field[type] is unset!'
      );
    }
    if (obj.mimeType != null) {
      output.writeFieldBegin('mimeType', thrift.TType.STRING, 2);
      output.writeString(obj.mimeType);
      output.writeFieldEnd();
    }
    if (obj.file != null) {
      output.writeFieldBegin('file', thrift.TType.STRING, 3);
      output.writeString(obj.file);
      output.writeFieldEnd();
    }
    if (obj.typeData != null) {
      output.writeFieldBegin('typeData', thrift.TType.STRUCT, 4);
      __NAMESPACE__.AssetFieldsCodec.encode(obj.typeData, output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  },
  decode(input: thrift.TProtocol): IAsset {
    let _args: any = {};
    input.readStructBegin();
    while (true) {
      const ret: thrift.IThriftField = input.readFieldBegin();
      const fieldType: thrift.TType = ret.fieldType;
      const fieldId: number = ret.fieldId;
      if (fieldType === thrift.TType.STOP) {
        break;
      }
      switch (fieldId) {
        case 1:
          if (fieldType === thrift.TType.I32) {
            const value_1: __NAMESPACE__.AssetType = input.readI32();
            _args.type = value_1;
          } else {
            input.skip(fieldType);
          }
          break;
        case 2:
          if (fieldType === thrift.TType.STRING) {
            const value_2: string = input.readString();
            _args.mimeType = value_2;
          } else {
            input.skip(fieldType);
          }
          break;
        case 3:
          if (fieldType === thrift.TType.STRING) {
            const value_3: string = input.readString();
            _args.file = value_3;
          } else {
            input.skip(fieldType);
          }
          break;
        case 4:
          if (fieldType === thrift.TType.STRUCT) {
            const value_4: __NAMESPACE__.IAssetFields = __NAMESPACE__.AssetFieldsCodec.decode(
              input
            );
            _args.typeData = value_4;
          } else {
            input.skip(fieldType);
          }
          break;
        default: {
          input.skip(fieldType);
        }
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    if (_args.type !== undefined) {
      return {
        type: _args.type,
        mimeType: _args.mimeType,
        file: _args.file,
        typeData: _args.typeData,
      };
    } else {
      throw new thrift.TProtocolException(
        thrift.TProtocolExceptionType.UNKNOWN,
        'Unable to read Asset from input'
      );
    }
  },
};
export class Asset extends thrift.StructLike implements IAsset {
  public type: __NAMESPACE__.AssetType;
  public mimeType?: string;
  public file?: string;
  public typeData?: __NAMESPACE__.IAssetFields;
  public readonly _annotations: thrift.IThriftAnnotations = {};
  public readonly _fieldAnnotations: thrift.IFieldAnnotations = {};
  constructor(args: IAssetArgs) {
    super();
    if (args.type != null) {
      const value_5: __NAMESPACE__.AssetType = args.type;
      this.type = value_5;
    } else {
      throw new thrift.TProtocolException(
        thrift.TProtocolExceptionType.UNKNOWN,
        'Required field[type] is unset!'
      );
    }
    if (args.mimeType != null) {
      const value_6: string = args.mimeType;
      this.mimeType = value_6;
    }
    if (args.file != null) {
      const value_7: string = args.file;
      this.file = value_7;
    }
    if (args.typeData != null) {
      const value_8: __NAMESPACE__.IAssetFields = new __NAMESPACE__.AssetFields(
        args.typeData
      );
      this.typeData = value_8;
    }
  }
  public static read(input: thrift.TProtocol): Asset {
    return new Asset(AssetCodec.decode(input));
  }
  public static write(args: IAssetArgs, output: thrift.TProtocol): void {
    return AssetCodec.encode(args, output);
  }
  public write(output: thrift.TProtocol): void {
    return AssetCodec.encode(this, output);
  }
}
