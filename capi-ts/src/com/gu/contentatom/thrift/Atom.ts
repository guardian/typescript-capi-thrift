/* tslint:disable */
/*
 * Autogenerated by @creditkarma/thrift-typescript v3.5.0
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 */
import * as thrift from '@creditkarma/thrift-server-core';
import * as __NAMESPACE__ from './.';
export interface IAtom {
  id: string;
  atomType: __NAMESPACE__.AtomType;
  labels: Array<string>;
  defaultHtml: string;
  data: __NAMESPACE__.IAtomData;
  contentChangeDetails: __NAMESPACE__.IContentChangeDetails;
  flags?: __NAMESPACE__.IFlags;
  title?: string;
  commissioningDesks?: Array<string>;
}
export interface IAtomArgs {
  id: string;
  atomType: __NAMESPACE__.AtomType;
  labels: Array<string>;
  defaultHtml: string;
  data: __NAMESPACE__.IAtomDataArgs;
  contentChangeDetails: __NAMESPACE__.IContentChangeDetailsArgs;
  flags?: __NAMESPACE__.IFlagsArgs;
  title?: string;
  commissioningDesks?: Array<string>;
}
export const AtomCodec: thrift.IStructCodec<IAtomArgs, IAtom> = {
  encode(args: IAtomArgs, output: thrift.TProtocol): void {
    const obj = {
      id: args.id,
      atomType: args.atomType,
      labels: args.labels,
      defaultHtml: args.defaultHtml,
      data: args.data,
      contentChangeDetails: args.contentChangeDetails,
      flags: args.flags,
      title: args.title,
      commissioningDesks:
        args.commissioningDesks != null ? args.commissioningDesks : [],
    };
    output.writeStructBegin('Atom');
    if (obj.id != null) {
      output.writeFieldBegin('id', thrift.TType.STRING, 1);
      output.writeString(obj.id);
      output.writeFieldEnd();
    } else {
      throw new thrift.TProtocolException(
        thrift.TProtocolExceptionType.UNKNOWN,
        'Required field[id] is unset!'
      );
    }
    if (obj.atomType != null) {
      output.writeFieldBegin('atomType', thrift.TType.I32, 2);
      output.writeI32(obj.atomType);
      output.writeFieldEnd();
    } else {
      throw new thrift.TProtocolException(
        thrift.TProtocolExceptionType.UNKNOWN,
        'Required field[atomType] is unset!'
      );
    }
    if (obj.labels != null) {
      output.writeFieldBegin('labels', thrift.TType.LIST, 3);
      output.writeListBegin(thrift.TType.STRING, obj.labels.length);
      obj.labels.forEach(
        (value_1: string): void => {
          output.writeString(value_1);
        }
      );
      output.writeListEnd();
      output.writeFieldEnd();
    } else {
      throw new thrift.TProtocolException(
        thrift.TProtocolExceptionType.UNKNOWN,
        'Required field[labels] is unset!'
      );
    }
    if (obj.defaultHtml != null) {
      output.writeFieldBegin('defaultHtml', thrift.TType.STRING, 4);
      output.writeString(obj.defaultHtml);
      output.writeFieldEnd();
    } else {
      throw new thrift.TProtocolException(
        thrift.TProtocolExceptionType.UNKNOWN,
        'Required field[defaultHtml] is unset!'
      );
    }
    if (obj.data != null) {
      output.writeFieldBegin('data', thrift.TType.STRUCT, 5);
      __NAMESPACE__.AtomDataCodec.encode(obj.data, output);
      output.writeFieldEnd();
    } else {
      throw new thrift.TProtocolException(
        thrift.TProtocolExceptionType.UNKNOWN,
        'Required field[data] is unset!'
      );
    }
    if (obj.contentChangeDetails != null) {
      output.writeFieldBegin('contentChangeDetails', thrift.TType.STRUCT, 6);
      __NAMESPACE__.ContentChangeDetailsCodec.encode(
        obj.contentChangeDetails,
        output
      );
      output.writeFieldEnd();
    } else {
      throw new thrift.TProtocolException(
        thrift.TProtocolExceptionType.UNKNOWN,
        'Required field[contentChangeDetails] is unset!'
      );
    }
    if (obj.flags != null) {
      output.writeFieldBegin('flags', thrift.TType.STRUCT, 7);
      __NAMESPACE__.FlagsCodec.encode(obj.flags, output);
      output.writeFieldEnd();
    }
    if (obj.title != null) {
      output.writeFieldBegin('title', thrift.TType.STRING, 8);
      output.writeString(obj.title);
      output.writeFieldEnd();
    }
    if (obj.commissioningDesks != null) {
      output.writeFieldBegin('commissioningDesks', thrift.TType.LIST, 9);
      output.writeListBegin(thrift.TType.STRING, obj.commissioningDesks.length);
      obj.commissioningDesks.forEach(
        (value_2: string): void => {
          output.writeString(value_2);
        }
      );
      output.writeListEnd();
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  },
  decode(input: thrift.TProtocol): IAtom {
    let _args: any = {};
    input.readStructBegin();
    while (true) {
      const ret: thrift.IThriftField = input.readFieldBegin();
      const fieldType: thrift.TType = ret.fieldType;
      const fieldId: number = ret.fieldId;
      if (fieldType === thrift.TType.STOP) {
        break;
      }
      switch (fieldId) {
        case 1:
          if (fieldType === thrift.TType.STRING) {
            const value_3: string = input.readString();
            _args.id = value_3;
          } else {
            input.skip(fieldType);
          }
          break;
        case 2:
          if (fieldType === thrift.TType.I32) {
            const value_4: __NAMESPACE__.AtomType = input.readI32();
            _args.atomType = value_4;
          } else {
            input.skip(fieldType);
          }
          break;
        case 3:
          if (fieldType === thrift.TType.LIST) {
            const value_5: Array<string> = new Array<string>();
            const metadata_1: thrift.IThriftList = input.readListBegin();
            const size_1: number = metadata_1.size;
            for (let i_1: number = 0; i_1 < size_1; i_1++) {
              const value_6: string = input.readString();
              value_5.push(value_6);
            }
            input.readListEnd();
            _args.labels = value_5;
          } else {
            input.skip(fieldType);
          }
          break;
        case 4:
          if (fieldType === thrift.TType.STRING) {
            const value_7: string = input.readString();
            _args.defaultHtml = value_7;
          } else {
            input.skip(fieldType);
          }
          break;
        case 5:
          if (fieldType === thrift.TType.STRUCT) {
            const value_8: __NAMESPACE__.IAtomData = __NAMESPACE__.AtomDataCodec.decode(
              input
            );
            _args.data = value_8;
          } else {
            input.skip(fieldType);
          }
          break;
        case 6:
          if (fieldType === thrift.TType.STRUCT) {
            const value_9: __NAMESPACE__.IContentChangeDetails = __NAMESPACE__.ContentChangeDetailsCodec.decode(
              input
            );
            _args.contentChangeDetails = value_9;
          } else {
            input.skip(fieldType);
          }
          break;
        case 7:
          if (fieldType === thrift.TType.STRUCT) {
            const value_10: __NAMESPACE__.IFlags = __NAMESPACE__.FlagsCodec.decode(
              input
            );
            _args.flags = value_10;
          } else {
            input.skip(fieldType);
          }
          break;
        case 8:
          if (fieldType === thrift.TType.STRING) {
            const value_11: string = input.readString();
            _args.title = value_11;
          } else {
            input.skip(fieldType);
          }
          break;
        case 9:
          if (fieldType === thrift.TType.LIST) {
            const value_12: Array<string> = new Array<string>();
            const metadata_2: thrift.IThriftList = input.readListBegin();
            const size_2: number = metadata_2.size;
            for (let i_2: number = 0; i_2 < size_2; i_2++) {
              const value_13: string = input.readString();
              value_12.push(value_13);
            }
            input.readListEnd();
            _args.commissioningDesks = value_12;
          } else {
            input.skip(fieldType);
          }
          break;
        default: {
          input.skip(fieldType);
        }
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    if (
      _args.id !== undefined &&
      _args.atomType !== undefined &&
      _args.labels !== undefined &&
      _args.defaultHtml !== undefined &&
      _args.data !== undefined &&
      _args.contentChangeDetails !== undefined
    ) {
      return {
        id: _args.id,
        atomType: _args.atomType,
        labels: _args.labels,
        defaultHtml: _args.defaultHtml,
        data: _args.data,
        contentChangeDetails: _args.contentChangeDetails,
        flags: _args.flags,
        title: _args.title,
        commissioningDesks:
          _args.commissioningDesks != null ? _args.commissioningDesks : [],
      };
    } else {
      throw new thrift.TProtocolException(
        thrift.TProtocolExceptionType.UNKNOWN,
        'Unable to read Atom from input'
      );
    }
  },
};
export class Atom extends thrift.StructLike implements IAtom {
  public id: string;
  public atomType: __NAMESPACE__.AtomType;
  public labels: Array<string>;
  public defaultHtml: string;
  public data: __NAMESPACE__.IAtomData;
  public contentChangeDetails: __NAMESPACE__.IContentChangeDetails;
  public flags?: __NAMESPACE__.IFlags;
  public title?: string;
  public commissioningDesks?: Array<string> = [];
  public readonly _annotations: thrift.IThriftAnnotations = {};
  public readonly _fieldAnnotations: thrift.IFieldAnnotations = {};
  constructor(args: IAtomArgs) {
    super();
    if (args.id != null) {
      const value_14: string = args.id;
      this.id = value_14;
    } else {
      throw new thrift.TProtocolException(
        thrift.TProtocolExceptionType.UNKNOWN,
        'Required field[id] is unset!'
      );
    }
    if (args.atomType != null) {
      const value_15: __NAMESPACE__.AtomType = args.atomType;
      this.atomType = value_15;
    } else {
      throw new thrift.TProtocolException(
        thrift.TProtocolExceptionType.UNKNOWN,
        'Required field[atomType] is unset!'
      );
    }
    if (args.labels != null) {
      const value_16: Array<string> = new Array<string>();
      args.labels.forEach(
        (value_23: string): void => {
          const value_24: string = value_23;
          value_16.push(value_24);
        }
      );
      this.labels = value_16;
    } else {
      throw new thrift.TProtocolException(
        thrift.TProtocolExceptionType.UNKNOWN,
        'Required field[labels] is unset!'
      );
    }
    if (args.defaultHtml != null) {
      const value_17: string = args.defaultHtml;
      this.defaultHtml = value_17;
    } else {
      throw new thrift.TProtocolException(
        thrift.TProtocolExceptionType.UNKNOWN,
        'Required field[defaultHtml] is unset!'
      );
    }
    if (args.data != null) {
      const value_18: __NAMESPACE__.IAtomData = new __NAMESPACE__.AtomData(
        args.data
      );
      this.data = value_18;
    } else {
      throw new thrift.TProtocolException(
        thrift.TProtocolExceptionType.UNKNOWN,
        'Required field[data] is unset!'
      );
    }
    if (args.contentChangeDetails != null) {
      const value_19: __NAMESPACE__.IContentChangeDetails = new __NAMESPACE__.ContentChangeDetails(
        args.contentChangeDetails
      );
      this.contentChangeDetails = value_19;
    } else {
      throw new thrift.TProtocolException(
        thrift.TProtocolExceptionType.UNKNOWN,
        'Required field[contentChangeDetails] is unset!'
      );
    }
    if (args.flags != null) {
      const value_20: __NAMESPACE__.IFlags = new __NAMESPACE__.Flags(
        args.flags
      );
      this.flags = value_20;
    }
    if (args.title != null) {
      const value_21: string = args.title;
      this.title = value_21;
    }
    if (args.commissioningDesks != null) {
      const value_22: Array<string> = new Array<string>();
      args.commissioningDesks.forEach(
        (value_25: string): void => {
          const value_26: string = value_25;
          value_22.push(value_26);
        }
      );
      this.commissioningDesks = value_22;
    }
  }
  public static read(input: thrift.TProtocol): Atom {
    return new Atom(AtomCodec.decode(input));
  }
  public static write(args: IAtomArgs, output: thrift.TProtocol): void {
    return AtomCodec.encode(args, output);
  }
  public write(output: thrift.TProtocol): void {
    return AtomCodec.encode(this, output);
  }
}
